# Extended Collection Types:
##   Collections module
##   Dictionary extensions
##   Named tuples
##   Double ended queue

# Counter Operations:
# most_common (list of elements and counts, sorted by count), 
# elements (expands a counter to a list; omits non-positive counts),
#  update (adds to counts instead of replacing them), subtract (subtracts counts, complements of update),
# The Counter can ofter substitute for a dict

# Example of using Counter type

from collections import Counter
c = Counter()
c['apples'] += 1
c['bananas'] +=1
c['apples'] +=2
c['cherries'] = 4

c.most_common()

c.elements() # return iterator

list(c.elements())

c.keys() #will return only unique elements

fruits = ['apples', 'apples', 'bananas', 'cherries', 'lemons', 'oranges', 'oranges']

shipment = Counter(fruits)
c.update(shipment)

sold = ['apples','apples', 'oranges', 'bananas']
sales = Counter(sold)
c.most_common()
    

# Other Dictionary Extensions

# defaultdict:
#   Generates default values for missing keys:
#   Default value is generated by
#    - Initializer for a type
#    - Factory function
#   Accessing a missing key raises no errors

# OrderedDict:
#   Insertion order of keys is maintained
#   Order is maintained even if value changes
#   Can remove a key from or move a key to either end
#    -popitem
#    -move_to_end
#   Raises an error for missing keys

# Example of using defaultdic:

from collections import defaultdict
str_dict = defaultdict(str)
str_dict['foo']
float_dict = defaultdict(float)
float_dict['foo']
int_dict = defaultdict(int)
int_dict['foo']
int_dict['apples'] += 1

class Fraction(object):
    def __init__(self):
        self.n = 1
        self.d = 2
    def __repr__(self):
        return '{0}/{1}'.format(self.n,self.d)

frac_dict = defaultdict(Fraction)
frac_dict['foo'] #it will return 1/2 as a default value
def dne(): return 'DNE'
dne_dict = defaultdict(dne)
dne_dict['foo'] #return 'DNE'
int_dict['hello'] = 'world'
int_dict #will return default(int, ['apples':1, 'foo':0, 'hello':'world'])
int_dict['0'] #returns 0

# Example of using OrderedDict:

from collections import OrderedDict
fruit = OrderedDict()
import random
for f in ['apples', 'bananas', 'cherries', 'lemons', 'limes', 'oranges', 'peacher']:
    fruit[f] = random.randint(50,100)

fruit

fruit['bananas'] = 50

fruit.move_to_end('bananas') #will move key to the end 

fruit

fruit.move_to_end('bananas', False) #will move key to the beginning of the text

fruit

fruit.popitem()
fruit
fruit.popitem(False) # will pop item the first item
fruit
# fruit['bananas'] - will return key Error

from collections import Counter

fruit_counter = Counter(fruit) #change from OrderedDict to Counter

fruit_counter #will return counter


#  Tuples vs Named Tuples
#  Tuples 
#  Built-in tuples:
#   - Linear, immutable, fixed-length
#   - Comma-delimited, surrounded by parentheses
#   - Values accessed by index
#   - Tuple values can be unpacked to multiple variables at the same time
#   - Linear, immutable, fixed-length

#   named tuple helps us to make call value of the tuple NOT by the index but by the name
#   Named Tuples
#   namedtuple() function
#   - Name of the type
#   - List of field names
#   - Returns a new type
#   A named tuple is still a tuple

from collections import namedtuple
ServerAddress = namedtuple('ServerAddress', ['ip_address','port'])

local_web_server = ServerAddress('127.0.0.1', 80)

local_web_server.ip_address

local_ssh_server = ServerAddress (port=22, ip_address='127.0.0.1')
local_ssh_server.port

local_ssh_server[1]

[m for m in dir(()) if not m.startswith('__')]

[m for m in dir(ServerAddress) if not m.startswith('__')]

Novel = namedtuple('Novel', ['title', 'author','publication_date'])

pride = Novel('Pride and Prejudice', 'Jane Austen', 1813)

book_title, author, published_id = pride

book_title

author

# Novel is still tuple and so on we cannot change values of it

local_web_server.ip_address

days_of_week = ('Sunday','Monday','Tuesday','Wednesday', 'Thursday', 'Friday','Saturday')

# Double Ended Queue
# Python has no specific stack or queue type
# Doubled-ended queue or deque
#   -Pronounced 'deck'
# Supports the same API as the list type (minus sorting)
# Can modify both ends of the deque
#   - appendleft()
#   - popleft()
#   - extendleft()
# Rotating a Deque, Circular Queue

# Example of using Deque

from collections import deque

deck = deque([2,3,5,7,11,17,19])

[m for m in dir(deque) if not m.startswith('__')]

deck2 = deque(maxlen=5)

deck2.extend(range(5))
deck2.append(10) #no error will occure 
#because last element will be replaced by the 10
deck2.appendleft(0)

primes = [2,3,5,7,11,13,17,19]

prime_deck = deque(primes)

prime_deck
prime_deck.rotate(4)
prime_deck

prime_deck.rotate(-2)
prime_deck

# example how to use it in case to check does all tasks completed
from collections import deque
import random

jq = deque()

for j in list('ABCD'):
    jq.append({'label':j,'completed':random.randint(5,25)})

while len(jq) > 0:
    current = jq[0]
    current['completed'] -= 5

    if current['completed'] > 0:
        print('Job {0} has {1} remaining'.format(current["label"],current['completed']))
    else:
        print('Job {0} has completed'.format(current["label"]))
        jq.remove(current)

    jq.rotate(1)

print('All jobs have been completed')


#   Data File Formats
# CSV
# Text file
# Represents tabular data
#   - spreadsheets
#   - database tables
# Each line in the file is a row
# Each item in the line is a column
# Items are delimited by commas
# Optional column headers

#   Reading CSVs Pythonically
# reader object
# - Iterable
# - Generic
# DictReader
# - Uses headers to match columns to values
# Dialects
# - Define features of CSV file
# - Sniffer class
# Close source file, not reader


#   Writing CSVs Pythonically
# writer object
# - writerow()
# - writerows()
# DictWriter
# - Field names as keyword argument
# writerow() takes a dict
# writeheader()

# JavaScript Object Notation (JSON)
# Simple text format describing key/value pairs
# Resembles a JS objects
# Common use in exchanging data across
# JSON also strongly resembles Python dictionaries and lists
# Native Python support in the json module
# simplejson is NOT recommended
# in JSON objects recommended to use double quotes ""

# Example of writing into JSON (the easy way)
import json

data = {"sales": [{'day':'Monday', 'revenue':100}, {'day':'Tuesday','revenue':200},{'day':'Wednesday','holiday':True}], 'expenses':14.99, 'fires':None}
json.dumps(data) 

# Example of reading JSON object (the easy way)

import json

s = '{"fires":null, "expenses":14.99,"sales":[{"revenue":100,"day":"Monday"},{"revenue":200, "day":"Tuesday"},{"day":"Wednesday","holiday":true}]}'
data = json.loads(s)
#print(sum([day for day in data['sales'] if 'revenue' in day.keys()]))

# Reading and Writing in Depth
# Load and dump functions
# - Read and write using files
# How to handle objects that can't be serialized to JSON
# Controlling the parsing of numbers to int and float
# In JSON there is only one numeric type so you cannot use int and flow in a same time
# Pass a hook to json.loads
# Subclass json.JSONEncoder & json.JSONDecoder

#
# Parsing and Generating JSON data
 



# XML
# Multiple APIs supported
# - Document Object Model (DOM)
# - Simple API for XML (SAX)
# - ElementTree 
# lxml (Pros:wrapper for large xml files, Cons: Separate Library, Dependent from C++ libraries)
# Special purpose packages
# - feedparser
# - BeautifulSoup


# Using Element Tree
# Parse either a file path or file object
# Simplified API

#import xml.etree.ElementTree as ET
#tree = ET.parse('courses.xml')
#course_els = tree.findall('course')
#course_names = [
#    course.find('title').text for course in course_els] 
# more Pythonic - attributes are a dictionary
#ratings = [
#    course.find('rating').attrib['stars'] for course in course_els]

# Generating XML via using Element Tree # Create Element with tag name
# course = ET.Element('course')
# title = ET.SubElement(course,'title') #Add SubElements with parent Element and tag name
# title.text = 'A New Course'
# rating = ET.SubElement(course, 'rating') #Modify properties of SubElements
# rating.attrib['stars'] = '5'
# rating.attrib['votes'] = '100' 
# ET.tostring(course) #tostring()

#   Modifying XML
# tree = ET.parse('course.xml')
# title = tree.find('.//course[@rank="10"]/title')#Subset of XPath
# title.text = 'Building RESTful APIs with ASP.NET Core' # Modify properties of elements directly
# rating = tree.find('.//course[@rank="10"]/rating') 
# rating.attrib['votes'] = '50' # Modify attribute keys directly
# rating.attrib['stars'] = '5'
# tree.write('filename.xml') # write text of tree to a file

#   Simple SQL Databases with SQLite
# SQLite 
# - file-based relational database
# - implements a subset of SQL
# - often used internally or for development
# Limited to storing a few Python types
# -int
# -float
# -str
# -None
# -bytes
# 
# WOrking with Sqlite3
# import sqlite3
# cn = sqlite3.connect('sample.db')
# cursor = cn.cursor()
# cursor.execute('create table todo (title text, priority integer)')
# cn.commit()
# cursor.execute("insert into todo values('Buy milk', 5)")
# cn.commit()
# cn.close() 

# assuming db is connected and opened already
# curson.execute("insert into todo values('Wash car', 1)")
# cursor.execute("insert into todo values('Finish slides',10)") 
# cn.commit()
# query.cursor.execute('select * from todo')
# for todo in query:
#   print(todo[0],todo[1])

# Row Factories
# A function that takes a cursor and row
# Can return any Python type
# - including namedtuple!
# Change the row factory after connecting to the database

# Creating a Row Factory
# from collections import namedtuple
# RowTodo = namedtuple('RowTodo', field_names=['title','priority'])
# def todo_factory(cursor, row):
#   return RowTodo(*row)
# cn = sqlite3.connect('sample.db')
# cn.row_factory = todo_factory
# cursor = cn.cursor()
# query = cursor.execute('select * from todo')
# for todo in query:
#   print(todo.title, todo.piority)


# Also SQLite3 supports
# Transactions
# Run Python functions
# Converting custom Python types
# Running external scripts
# Loading external data sources
 
# Common file formats in the Python Standard Library

# csv
# -flat, tabular data
# 
# JSON
# -hierarchical data
# -transport format over HTTP
# 
# xml
# -marked up hierarchical data
# -archival format
# 
# sqlite3
# -simple file-based SQL-like database 


# Handling Internet Data
# urllib:
# urllib.request 
# For opening URLs, usually employing the HTTP protocol
#   urlopen()
#   -At a minimum, argument is a URL
#   -Returns an HTTPResponse from the http module
#   -Functions much like a file handle
# Build requests manually
#   -urllib.request.Request
#   -Specific method
#   -Custom headers

#   Example of using urlopen
# from urllib.request import urlopen
# conn = urlopen('http://pluralsight.com')
# conn.status
# conn.reason
# lines = conn.readlines()
# data = ''.join([line.decode('utf-8') for line in lines])
#    Do something with the data
# conn.close()

#    Example of using Request
# from urlib.request import Request
# req = Request(url='http://pluralsight.com')
# req = Request(url='http://someserver.com',mehtod='POST',
#   data=b'some bytes',
# headers=[('User-Agent','PythonDemo/0.1')])
# req.add_header('Content-Type','applicaiton/json')
# conn = urlopen(req)
#   do something with connection
# conn.close()
#  

#   urllib.parse
# Works with the URL itself
# Discovering components
#   -URL scheme
#   -path
#   -query
# Parsing query strings
# Quoting


# Example of using parsing URLs via urllib.parse
# from ullib.parse import urlparse
# url = 'htp://example.com/list?sort=price&filter=type'
# result = urlparse(url)
# result.scheme #http
# result.path   # /list
# result.query  #sort=price&filter=type


# Parsing Query Strings
# from urllib.parse import urlparse, parse_qs
# url = 'http://example.com/list?sort=price&filter=type'
# result = urlparse(url)
# qs_data = parse_qs(result.query)


# urllib.error
# Convenience module
# URLError
# HTTPError
#   -Status code
#   -Reason string

from urllib.request import urlopen
url = 'http://pluralsight.com'
conn = urlopen(url)

type(conn)
dir(conn)
conn.url
conn.status
conn.reason
lines = conn.readlines()
# data = ''.join(lines) #will throw error because of data is byte string
data = ''.join([line.decode('utf-8') for line in lines])
conn.close()
# go to hookbin.com and grab your own url link

url = "https://hookb.in/vqLyAmyz"

method='POST'
data = b'{"message":"hello world"}' #we need to send BINARY string
headers = {'Content-Type':'application/json'}
import urllib.request as q
request = q.Request(url, method=method, data=data, headers=headers)
conn = urlopen(request)
lines = ''.join([line.decode('utf-8') for line in conn.readlines()])
conn.close()
print(lines)



#   http
# Low level access to the HTTP protocol
# Leveraged by urllib
# Support serving content in additional to  retrieving
# Cookie handling

# Example of using http.client
# from http.client import HTTPConnection
# conn = HTTPConnection('pluralsight.com',80)
# conn.request('GET','/')
# res = conn.getresponse()
# data = ''.join([line.decode('utf-8') for line in res.readlines()]) 
#    Do something with data
# conn.close()

# Example of using http.server
# from http.server import HTTPServer, BaseHTTP 
# server = HTTPServer(('',8888), BaseHTTPRequestHandler)
# server.serve_forever()

# Another example of using http.server
# from http.server import HTTPServer, SimpleHTTPRequestHandler
# server = HTTPServer(('',8888), SimpleHTTPRequestHandler)
# server.serve_forever()

# Custom HTTP Handler Classes
# from http.server import HTTPServer, BaseHTTPRequestHandler
# class DemoHandler(BaseHTTPRequestHandler):
#   def do_GET(self):
#       self.send_response(200)
#       self.end_headers()
#       self.wfile.write(b'This is a GET request')
# server = HTTPServer(('',8888),DemoHandler)
# server.serve_forever()


# Accessing REST Web Services
'''
from urllib.request import Request, urlopen
import json

APPLICATION_ID = 'f3319151-8f35-4680-9b4a-1849762fd240'
REST_API_KEY = 'PNpL39J5vvK9kZ93Z3Al01ApdbESohOZ'

BASE_URL = 'https://parse.buddy.com/parse'

CLASSES = '/classes'
CLASS_COURSE ='/course'

PARSE_HEADERS = {
    'X-Parse-Application-Id': APPLICATION_ID,
    'X-Parse-REST-API-Key': REST_API_KEY,
    'Content-Type': 'application/json'
}

def create_course(title, author_first_name, author_last_name):
    url = BASE_URL + CLASSES + CLASS_COURSE

    data = {
        'title':title,
        'author_first_name':author_first_name,
        'author_last_name':author_last_name,
        'votes':0,
        'stars':0
    }

    q = Request(url, method='POST', headers=PARSE_HEADERS, data=json.dump(data).encode('utf-8'))
    conn = urlopen(q)
    s_data = ''.join([line.decode('utf-8') for line in conn.readlines()])
    result = json.loads(s_data)
    print(result)

if __name__=='__main__':
    create_course('Getting Started with the Python Standard Library','Douglas','Starnes')
'''

# Email
# POP3 (Post Office Protocol)
# -poplib
# SMTP (Simple Mail Transfer Protocol)
# -smtplib
# -smptd
# IMAP (Internet Message Access Protocol)
# -imaplib
# -gmail
# Other Protocols
# FTP (File Transfering Protocol)
# -ftplib
# Telnet
# -telnetlib
# NNTP (Network News Transfer Protocol)
# -nntplib
# Everything else
# -socket
# -socketserver
# -ssl
# -Twisted Matrix (not standard library)


#   Summary
# Web Data
# urllib -opening and parsing URLs
# http -low-level HTTP client and server
# Email
# -POP3, SMTP, IMAP
# Other Protocos
# -FTP, Telnet,NNTP, sockets
# 3rd Party Packages: Twisted Matrix, requests


# Regular Expressions
# re module
# A regex pattern is compiled
# - Regular expression object
# Pattern is executed
# -Match object
# -List
# -None
# Match object contains match data
# -Start
# -End
# -Range


# Utility modules
# Random Data Selection and Generation
# String Processing
# Argument Parsing

#   Random Data Selection and Generation
# random()
# -float between 0 and 1.0-exclusive
# uniform(m,n)
# -float between m and n-inclusive
# normalvariate(mean,stdev)
# -normal distribution
# randint(a,b)
# -int betwwen a and b-inclusive
# ranrange(a,b)
# -int between a and b-exclusive
# -optional step

#   Sequence Data
# choice
# -returns an element from a sequence
# sample
# -returns a set of unique elements from a sequence
# shuffle
# -reorder the elements in a sequence
# -in place


# Seeding (to generate as randomly as possible, previous solutions were pseudo-random functions)
# seed(n)
# -reproduce the same random sequence for n

# Template strings
# -placeholders prefixed with '$'
# -$value is replaced with variable value
# -use '$$' in place of '$'
# Template class
# -substitue()
# -dictionary where keys are placeholders
# -keyword arguments 





